# -*- coding: utf-8 -*-

"""
/***************************************************************************
 FireToolbox
                                 A QGIS plugin
 A collection of fire insights related algorithms
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-08-30
        copyright            : (C) 2023 by Fernando Badilla Veliz - Fire2a.com
        email                : fbadilla@ing.uchile.cl
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
TODO:
    group results https://gis.stackexchange.com/questions/416542/adding-output-layers-of-qgis-processing-scripts-to-group-using-pyqgis
util:
    https://gis.stackexchange.com/questions/314036/programmatically-styling-layer-after-output-is-returned-from-qgis-3-processing-s
    https://lists.osgeo.org/pipermail/qgis-developer/2021-June/063741.html
    https://gis.stackexchange.com/questions/375987/customizing-qgsprocessing-output-layer-name
    https://gis.stackexchange.com/questions/448603/change-the-symbology-of-a-vector-output-layer-that-is-returned-from-a-processing
    https://gis.stackexchange.com/questions/414559/qgis-iterative-rasterize-naming
    https://gis.stackexchange.com/questions/306659/pyqgis-style-layer-after-processing-with-qml-file

"""

__author__ = "Fernando Badilla Veliz - Fire2a.com"
__date__ = "2023-08-30"
__copyright__ = "(C) 2023 by Fernando Badilla Veliz - Fire2a.com"

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = "$Format:%H$"

from datetime import datetime
from math import isclose
from multiprocessing import cpu_count
from os import kill
from pathlib import Path
from platform import system as platform_system
from re import search
from shutil import copy
from signal import SIGKILL
from time import sleep
from typing import Any

import processing
from fire2a.raster import get_geotransform, id2xy, transform_coords_to_georef
from numpy import array, float32, int16, int32, loadtxt, random
from osgeo import gdal
from qgis.core import (Qgis, QgsApplication, QgsFeature, QgsFeatureSink,
                       QgsField, QgsFields, QgsGeometry, QgsLineString,
                       QgsMessageLog, QgsPoint, QgsProcessing,
                       QgsProcessingAlgorithm, QgsProcessingContext,
                       QgsProcessingException, QgsProcessingParameterBoolean,
                       QgsProcessingParameterEnum,
                       QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterFile,
                       QgsProcessingParameterFolderDestination,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterRasterLayer,
                       QgsProcessingParameterVectorLayer, QgsProject,
                       QgsRasterLayer, QgsTask, QgsVectorLayer)
from qgis.PyQt.QtCore import QCoreApplication, QVariant

plugin_dir = Path(__file__).parent
assets_dir = Path(plugin_dir, "simulator")


class PostSimulationAlgorithm(QgsProcessingAlgorithm):
    """Cell2Fire results post processing bundle"""

    INSTANCE_DIR = "InstanceDirectory"
    RESULTS_DIR = "ResultsDirectory"
    OUTPUTS = "RequestedOutputs"
    OUTPUT_DIR = "OutputFolder"
    output_options = [
        "Final fire scar",
        "Propagation fire scars",
        "Propagation directed-graph",
        "Hit rate of spread",
        "Flame Length",
        "Byram Intensity",
        "Crown Fire Scar",
        "Crown Fire Fuel Consumption",
        # "Betweenness Centrality",
        # "Downstream Protection Value",
    ]

    def initAlgorithm(self, config):
        """inputs and output of the algorithm"""
        project_path = QgsProject().instance().absolutePath()
        self.addParameter(
            QgsProcessingParameterFile(
                name=self.INSTANCE_DIR,
                description="Cell2 Fire Simulator INSTANCE directory (normally firesim_yymmdd_HHMMSS)",
                behavior=QgsProcessingParameterFile.Folder,
                extension="",
                defaultValue=project_path if project_path != "" else None,
                optional=False,
                fileFilter="",
            )
        )
        self.addParameter(
            QgsProcessingParameterFile(
                name=self.RESULTS_DIR,
                description="Cell2 Fire Simulator RESULTS directory (normally firesim_yymmdd_HHMMSS/results)",
                behavior=QgsProcessingParameterFile.Folder,
                extension="",
                defaultValue=project_path if project_path != "" else None,
                optional=False,
                fileFilter="",
            )
        )
        self.addParameter(
            QgsProcessingParameterEnum(
                name=self.OUTPUTS,
                description=self.tr("Requested Options (subset of requested for simulation)"),
                options=self.output_options,
                allowMultiple=True,
                defaultValue=list(range(len(self.output_options))),
            )
        )
        self.addParameter(
            QgsProcessingParameterFolderDestination(
                name=self.OUTPUT_DIR,
                description="Output directory",
                defaultValue=None,
                optional=True,
                createByDefault=True,
            )
        )

    def checkParameterValues(self, parameters: dict[str, Any], context: QgsProcessingContext) -> tuple[bool, str]:
        """log file exists and is not empty"""
        instance_directory = Path(self.parameterAsString(parameters, self.INSTANCE_DIR, context))
        fuels = Path(instance_directory, "fuels.asc")
        if not fuels.is_file() and fuels.stat().st_size > 0:
            return False, f"fuels.asc file not found or empty in instance directory: ({results_directory})"
        results_directory = Path(self.parameterAsString(parameters, self.RESULTS_DIR, context))
        log_file = Path(results_directory, "LogFile.txt")
        if not log_file.is_file() and log_file.stat().st_size > 0:
            return False, f"LogFile.txt file not found or empty in results directory: ({results_directory})"
        return True, ""

    def processAlgorithm(self, parameters, context, feedback):
        """Here is where the processing itself takes place."""
        feedback.pushDebugInfo("processAlgorithm start")
        feedback.pushDebugInfo(f"context args: {context.asQgisProcessArguments()}")
        # feedback.pushDebugInfo(f"parameters {parameters}")
        # GET OPTIONS
        output_options = self.parameterAsEnums(parameters, self.OUTPUTS, context)
        output_options_strings = array(self.output_options)[output_options]
        feedback.pushDebugInfo(f"output_options: {output_options_strings}\n")
        # OUTPUT DIR
        output_directory = Path(self.parameterAsString(parameters, self.OUTPUT_DIR, context))
        # INSTANCE DIR
        instance_directory = Path(self.parameterAsString(parameters, self.INSTANCE_DIR, context))
        # RESULTS DIR
        results_directory = Path(self.parameterAsString(parameters, self.RESULTS_DIR, context))
        # log file
        log_file = Path(results_directory, "LogFile.txt")
        log_text = log_file.read_text(encoding="utf-8")
        feedback.pushDebugInfo(log_text[:80])

        if "Propagation directed-graph" in output_options_strings:
            msg_out = processing.run(
                "fire2a:messages",
                {
                    "BaseLayer": str(Path(instance_directory, "fuels.asc")),
                    "MessagesDirectory": str(Path(results_directory, "Messages")),
                    "PropagationDirectedGraph": QgsProcessing.TEMPORARY_OUTPUT,
                },
                context=context,
                feedback=feedback,
                is_child_algorithm=True,
            )
            context.addLayerToLoadOnCompletion(
                msg_out["PropagationDirectedGraph"],
                QgsProcessingContext.LayerDetails(
                    "propagation_directed_graph",
                    context.project(),
                    "messages",
                ),
            )
        # context.temporaryLayerStore().addMapLayer(lyr_out)
        # lyr_out_str = msg_out["PropagationDirectedGraph"]
        # lyr_out = context.takeResultLayer(lyr_out_str)
        # context.addLayerToLoadOnCompletion(
        #     lyr_out_str, QgsProcessingContext.LayerDetails("messages", QgsProject.instance(), "")
        # )
        return {self.OUTPUT_DIR: str(output_directory), "MSG_OUT": msg_out}

    def name(self):
        return "simulationresultsprocessing"

    def displayName(self):
        return self.tr("All together bundle")

    def group(self):
        return self.tr("Simulator Post Processing")

    def groupId(self):
        return "simulatorpostprocessing"

    def tr(self, string):
        return QCoreApplication.translate("Processing", string)

    def createInstance(self):
        return PostSimulationAlgorithm()


class MessagesSIMPP(QgsProcessingAlgorithm):
    # INSTANCE_DIR = "InstanceDirectory"
    BASE_LAYER = "BaseLayer"
    MSGS_DIR = "MessagesDirectory"
    OUTPUT_LAYER = "PropagationDirectedGraph"

    def checkParameterValues(self, parameters: dict[str, Any], context: QgsProcessingContext) -> tuple[bool, str]:
        """log file exists and is not empty
        debug:
            output_dir = Path('/home/fdo/source/C2F-W/data/Homogeneous_kitral/firesim_230922_135815/results')
            output_dir.is_dir()
            msg_dir = Path(output_dir, "Messages")
            msg_dir.is_dir()
            not any([ afile for afile in files if afile.is_file() and afile.stat().st_size>0 ])
        """
        msg_dir = Path(self.parameterAsString(parameters, self.MSGS_DIR, context))
        if not msg_dir.is_dir():
            return False, f"Provided {self.MSGS_DIR}: {msg_dir} is not a directory"
        files = list(msg_dir.glob("MessagesFile[0-9]*.csv"))
        if files == []:
            return False, f"Provided {self.MSGS_DIR}: {msg_dir} does not contain any 'MessagesFile[0-9]*.csv' files"
        if not any([afile for afile in files if afile.is_file() and afile.stat().st_size > 0]):
            return False, f"Provided {self.MSGS_DIR}: {msg_dir} contains only empty 'MessagesFile[0-9]*.csv' file"
        return True, ""

    def initAlgorithm(self, config):
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                name=self.OUTPUT_LAYER,
                description=self.tr("Output vector layer"),
                type=QgsProcessing.TypeVectorLine,
            )
        )
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                name=self.BASE_LAYER,
                description=self.tr("Base raster (normally fuel or elevation) to get the geotransform"),
                defaultValue=[QgsProcessing.TypeRaster],
                optional=False,
            )
        )
        self.addParameter(
            QgsProcessingParameterFile(
                name=self.MSGS_DIR,
                description="Cell2 Fire Simulator Messages directory (normally firesim_yymmdd_HHMMSS/results/Messages)",
                behavior=QgsProcessingParameterFile.Folder,
                extension="",
                defaultValue=None,
                optional=False,
                fileFilter="",
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        """
        msgs_files = sorted(list(Path(output_dir, "Messages").glob("MessagesFile[0-9]*.csv")))
        """
        feedback.pushDebugInfo("processAlgorithm start")
        # get base map
        base_raster = self.parameterAsRasterLayer(parameters, self.BASE_LAYER, context)
        dataset = gdal.Open(base_raster.publicSource(), gdal.GA_ReadOnly)
        if dataset is None:
            raise FileNotFoundError(filename)
        GT = dataset.GetGeoTransform()
        # "Projection": ds.GetProjection(),
        # "RasterCount": ds.RasterCount,
        W = dataset.RasterXSize
        H = dataset.RasterYSize
        # set output layer
        fields = QgsFields()
        fields.append(QgsField(name="simulation", type=QVariant.Int, len=10))
        fields.append(QgsField(name="time", type=QVariant.Int, len=10))
        (sink, dest_id) = self.parameterAsSink(
            parameters, self.OUTPUT_LAYER, context, fields, Qgis.WkbType.MultiLineString, base_raster.crs()
        )

        # get messages
        msg_dir = Path(self.parameterAsString(parameters, self.MSGS_DIR, context))
        files = []
        for afile in msg_dir.glob("MessagesFile[0-9]*.csv"):
            if afile.is_file() and afile.stat().st_size > 0:
                files += [afile]
        feedback.pushDebugInfo(f"{len(files)} messages files, first: {files[0]}...")
        # build digraphs
        for count, afile in enumerate(files):
            sim_idx = search("\\d+", afile.stem).group(0)
            data = loadtxt(afile, delimiter=",", dtype=[("i", int32), ("j", int32), ("time", int32)], usecols=(0, 1, 2))
            feedback.pushDebugInfo(f"simulation id: {sim_idx}, edges: {len(data)}")
            # build line add to sink
            for i, j, time in data:
                i_x_px, i_y_ln = id2xy(i - 1, W, H)
                i_x_geo, i_y_geo = transform_coords_to_georef(i_x_px + 0.5, i_y_ln + 0.5, GT)
                # feedback.pushDebugInfo(f"i_x_geo, i_y_geo: {i_x_geo}, {i_y_geo}, time: {time}")
                j_x_px, j_y_ln = id2xy(j - 1, W, H)
                j_x_geo, j_y_geo = transform_coords_to_georef(j_x_px + 0.5, j_y_ln + 0.5, GT)
                # feedback.pushDebugInfo(f"j_x_geo, j_y_geo: {j_x_geo}, {j_y_geo}, time: {time}")
                # TODO id = int(f"{sim_idx.zfill}_{i.zfill...}_{j}")
                feature = QgsFeature(fields)
                feature.setAttributes([int(sim_idx), int(time)])
                feature.setGeometry(QgsLineString([QgsPoint(i_x_geo, i_y_geo), QgsPoint(j_x_geo, j_y_geo)]))
                # feedback.pushDebugInfo(f"j_x_geo, j_y_geo: {j_x_geo}, {j_y_geo}, time: {time}, sim_idx: {sim_idx}")
                sink.addFeature(feature, QgsFeatureSink.FastInsert)
                if feedback.isCanceled():
                    break
            feedback.setProgress(int(count * len(files)))

        processing.run(
            "qgis:setstyleforvectorlayer",
            {"INPUT": dest_id, "STYLE": str(Path(assets_dir, "messages.qml"))},
            context=context,
            feedback=feedback,
            is_child_algorithm=True,
        )
        # self.dest_id = dest_id
        return {self.OUTPUT_LAYER: dest_id}

    # def postProcessAlgorithm(self, context, feedback):
    #     """Called after processAlgorithm, use it to load the layer and set the symbology"""
    #     feedback.pushDebugInfo(f"postProcessAlgorithm start {context}")
    #     # layer = QgsProcessingUtils.mapLayerFromString(self.dest_id, context)
    #     layer = context.getMapLayer(self.dest_id)
    #     layer.loadNamedStyle(str(Path(assets_dir, "messages.qml")))
    #     # layer.triggerRepaint()
    #     return {self.OUTPUT_LAYER: self.dest_id}

    def createInstance(self):
        return MessagesSIMPP()

    def tr(self, string):
        return QCoreApplication.translate("Processing", string)

    def createInstance(self):
        return MessagesSIMPP()

    def group(self):
        return self.tr("Simulator Post Processing")

    def groupId(self):
        return "simulatorpostprocessing"

    def name(self):
        return "messages"

    def displayName(self):
        return self.tr("Messages")
