# -*- coding: utf-8 -*-

"""
/***************************************************************************
 FireToolbox
                                 A QGIS plugin
 A collection of fire insights related algorithms
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-08-30
        copyright            : (C) 2023 by Fernando Badilla Veliz - Fire2a.com
        email                : fbadilla@ing.uchile.cl
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
TODO:
    group results https://gis.stackexchange.com/questions/416542/adding-output-layers-of-qgis-processing-scripts-to-group-using-pyqgis
util:
    https://gis.stackexchange.com/questions/314036/programmatically-styling-layer-after-output-is-returned-from-qgis-3-processing-s
    https://lists.osgeo.org/pipermail/qgis-developer/2021-June/063741.html
    https://gis.stackexchange.com/questions/375987/customizing-qgsprocessing-output-layer-name
    https://gis.stackexchange.com/questions/448603/change-the-symbology-of-a-vector-output-layer-that-is-returned-from-a-processing
    https://gis.stackexchange.com/questions/414559/qgis-iterative-rasterize-naming
    https://gis.stackexchange.com/questions/306659/pyqgis-style-layer-after-processing-with-qml-file

"""

__author__ = "Fernando Badilla Veliz - Fire2a.com"
__date__ = "2023-08-30"
__copyright__ = "(C) 2023 by Fernando Badilla Veliz - Fire2a.com"

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = "$Format:%H$"

from os import sep
from pathlib import Path
from re import findall, search
from typing import Any

import processing
from fire2a.raster import get_geotransform, id2xy, read_raster, transform_coords_to_georef
from grassprovider.Grass7Utils import Grass7Utils
from matplotlib import colormaps
from matplotlib.colors import to_rgba_array
from numpy import any, argsort, array, dtype, float32, fromiter, int16, int32, linspace, loadtxt, unique
from osgeo import gdal
from osgeo.gdal import GA_ReadOnly, GCI_PaletteIndex, GDT_Float32, GDT_Int16
from qgis.core import (Qgis, QgsApplication, QgsColorRampShader, QgsFeature, QgsFeatureSink, QgsField, QgsFields,
                       QgsGeometry, QgsGradientColorRamp, QgsGraduatedSymbolRenderer, QgsLineString, QgsMessageLog,
                       QgsPalettedRasterRenderer, QgsPoint, QgsProcessing, QgsProcessingAlgorithm, QgsProcessingContext,
                       QgsProcessingException, QgsProcessingLayerPostProcessorInterface, QgsProcessingParameterBoolean,
                       QgsProcessingParameterDefinition, QgsProcessingParameterEnum, QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterFile, QgsProcessingParameterFolderDestination,
                       QgsProcessingParameterNumber, QgsProcessingParameterRasterDestination,
                       QgsProcessingParameterRasterLayer, QgsProcessingParameterString,
                       QgsProcessingParameterVectorLayer, QgsProcessingUtils, QgsProject, QgsRasterBandStats,
                       QgsRasterLayer, QgsRasterShader, QgsSingleBandPseudoColorRenderer, QgsTask, QgsVectorLayer)
from qgis.PyQt.QtCore import QCoreApplication, QVariant
from qgis.PyQt.QtGui import QColor

from .config import METRICS, NAME, SIM_OUTPUTS, STATS, TAG, jolo

plugin_dir = Path(__file__).parent
assets_dir = Path(plugin_dir, "simulator")


class IgnitionPointsSIMPP(QgsProcessingAlgorithm):
    """Ignition Points Simulation Post Processing Algorithm load LogFile.txt and create a point layer"""

    BASE_LAYER = "BaseLayer"
    IN_LOG = "LogFile"
    OUT_LAYER = "IgnitionPointsLayer"

    def checkParameterValues(self, parameters: dict[str, Any], context: QgsProcessingContext) -> tuple[bool, str]:
        """log file exists and is not empty"""
        log_file = Path(self.parameterAsString(parameters, self.IN_LOG, context))
        if not log_file.stat().st_size > 0:
            return False, f"{log_file} file is empty!"
        log_text = log_file.read_text(encoding="utf-8")
        simulation_id, ignition_cell = fromiter(
            findall("ignition point for Year [0-9]*, sim ([0-9]+): ([0-9]+)", log_text), dtype=dtype((int32, 2))
        ).T
        if len(simulation_id) == 0 or len(ignition_cell) == 0:
            return (
                False,
                (
                    f"{log_file} file does not contain any match for ignition points: 'ignition point for Year [0-9]*,"
                    " sim ([0-9]+): ([0-9]+)'"
                ),
            )
        return True, ""

    def initAlgorithm(self, config):
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                name=self.BASE_LAYER,
                description=self.tr("Base raster (normally fuel or elevation) to get the geotransform"),
                defaultValue=[QgsProcessing.TypeRaster],
                optional=False,
            )
        )
        self.addParameter(
            QgsProcessingParameterFile(
                name=self.IN_LOG,
                description="Simulator log file (normally firesim_yymmdd_HHMMSS/results/LogFile.txt)",
                behavior=QgsProcessingParameterFile.File,
                extension="txt",
                defaultValue=None,
                optional=False,
            )
        )
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                name=self.OUT_LAYER,
                description=self.tr("Output ignition point(s) layer"),
                type=QgsProcessing.TypeVectorPoint,
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        """Here is where the processing itself takes place."""
        # BASE LAYER
        base_raster = self.parameterAsRasterLayer(parameters, self.BASE_LAYER, context)
        _, raster_props = read_raster(base_raster.publicSource(), data=False)
        feedback.pushDebugInfo(f"base_raster.crs(): {base_raster.crs()}")
        # log file
        log_text = Path(self.parameterAsString(parameters, self.IN_LOG, context)).read_text(encoding="utf-8")
        feedback.pushDebugInfo(f"sample of simulation log: {log_text[-30:30]}")
        # create layer
        fields = QgsFields()
        fields.append(QgsField(name="simulation", type=QVariant.Int, len=10))
        fields.append(QgsField(name="cell", type=QVariant.Int, len=10))
        fields.append(QgsField(name="x_pixel", type=QVariant.Int, len=10))
        fields.append(QgsField(name="y_line", type=QVariant.Int, len=10))
        (sink, dest_id) = self.parameterAsSink(
            parameters,
            self.OUT_LAYER,
            context,
            fields,
            Qgis.WkbType.Point,
            base_raster.crs(),
        )
        feedback.pushDebugInfo(f"dest_id: {dest_id}, type: {type(dest_id)}")
        feedback.pushDebugInfo(f"sink: {sink}, type: {type(sink)}, dir: {dir(sink)}")
        # parse log file
        simulation_id, ignition_cell = fromiter(
            findall("ignition point for Year [0-9]*, sim ([0-9]+): ([0-9]+)", log_text), dtype=dtype((int32, 2))
        ).T
        ignition_cell -= 1  # 1 based to 0 based
        # add features
        features = []
        for sim_id, cell in zip(simulation_id, ignition_cell):
            i, j = id2xy(cell, raster_props["RasterXSize"], raster_props["RasterYSize"])
            x, y = transform_coords_to_georef(i + 0.5, j + 0.5, raster_props["Transform"])
            feature = QgsFeature(fields)
            feature.setId(int(sim_id))
            feature.setAttributes([int(sim_id), int(cell + 1), int(i), int(j)])
            feature.setGeometry(QgsGeometry(QgsPoint(x, y)))
            sink.addFeature(feature, QgsFeatureSink.FastInsert)
            feedback.pushDebugInfo(f"simulation id: {sim_id}, ignition cell: {cell}, x: {x}, y: {y}, i: {i}, j: {j}")
            if feedback.isCanceled():
                break
        feedback.pushDebugInfo(f"addFeatures: {sink}, {type(sink)}")
        processing.run(
            "qgis:setstyleforvectorlayer",
            {"INPUT": dest_id, "STYLE": str(Path(assets_dir, "ignition_points.qml"))},
            context=context,
            feedback=feedback,
            is_child_algorithm=True,
        )
        if context.willLoadLayerOnCompletion(dest_id):
            layer = QgsProcessingUtils.mapLayerFromString(dest_id, context)
            layer_details = context.LayerDetails(
                layer.name(), context.project(), dest_id, QgsProcessingUtils.LayerHint.Vector
            )
            layer_details.groupName = NAME["layer_group"]
            layer_details.layerSortKey = 0
            context.addLayerToLoadOnCompletion(dest_id, layer_details)
        return {self.OUT_LAYER: dest_id}

    def tr(self, string):
        return QCoreApplication.translate("Processing", string)

    def createInstance(self):
        return IgnitionPointsSIMPP()

    def group(self):
        return self.tr("Simulator Post Processing")

    def groupId(self):
        return "simulatorpostprocessing"

    def name(self):
        return "ignitionpoints"

    def displayName(self):
        return self.tr("Ignition Points")


class PostSimulationAlgorithm(QgsProcessingAlgorithm):
    """Cell2Fire results post processing bundle"""

    BASE_LAYER = "BaseLayer"
    RESULTS_DIR = "ResultsDirectory"
    OUTPUT_DIR = "OutputDirectory"
    output_options = SIM_OUTPUTS
    OUTPUTS = "Outputs"

    def initAlgorithm(self, config):
        """inputs and output of the algorithm"""
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                name=self.BASE_LAYER,
                description=self.tr("Base raster (normally fuel or elevation) to get the geotransform"),
                defaultValue=[QgsProcessing.TypeRaster],
                optional=False,
            )
        )
        project_path = QgsProject().instance().absolutePath()
        self.addParameter(
            QgsProcessingParameterFile(
                name=self.RESULTS_DIR,
                description="Cell2 Fire Simulator RESULTS directory (normally firesim_yymmdd_HHMMSS/results)",
                behavior=QgsProcessingParameterFile.Folder,
                extension="",
                defaultValue=project_path if project_path != "" else None,
                optional=False,
                fileFilter="",
            )
        )
        for sim_out in SIM_OUTPUTS:
            self.addParameter(
                QgsProcessingParameterBoolean(
                    name=sim_out["name"].replace(" ", ""),
                    description=sim_out["name"],
                    defaultValue=True,
                    optional=False,
                )
            )
        self.addParameter(
            QgsProcessingParameterFolderDestination(
                name=self.OUTPUT_DIR,
                description="Output directory",
                defaultValue=None,
                optional=True,
                createByDefault=True,
            )
        )

    def checkParameterValues(self, parameters: dict[str, Any], context: QgsProcessingContext) -> tuple[bool, str]:
        results_directory = Path(self.parameterAsString(parameters, self.RESULTS_DIR, context))
        if not results_directory.is_dir():
            return False, f"provided results is not a directory: {results_directory}"
        if not any(results_directory.iterdir()):
            return False, f"provided results is empty: {results_directory}"
        return True, ""

    def processAlgorithm(self, parameters, context, feedback):
        """Here is where the processing itself takes place."""
        feedback.pushDebugInfo("processAlgorithm start")
        feedback.pushDebugInfo(f"context args: {context.asQgisProcessArguments()}")
        # feedback.pushDebugInfo(f"parameters {parameters}")
        # GET OPTIONS
        output_options = self.parameterAsEnums(parameters, self.OUTPUTS, context)
        output_options_strings = array(self.output_options)[output_options]
        feedback.pushDebugInfo(f"output_options: {output_options_strings}\n")
        # OUTPUT DIR
        output_directory = Path(self.parameterAsString(parameters, self.OUTPUT_DIR, context))
        # BASE LAYER
        base_raster = self.parameterAsRasterLayer(parameters, self.BASE_LAYER, context)
        # _, raster_props = read_raster(base_raster.publicSource(), data=False)
        # RESULTS DIR
        results_directory = Path(self.parameterAsString(parameters, self.RESULTS_DIR, context))

        msg_out = None
        if "Propagation directed-graph" in output_options_strings:
            msg_out = processing.run(
                "fire2a:messages",
                {
                    "BaseLayer": base_raster,
                    "MessagesDirectory": str(Path(results_directory, "Messages")),
                    "PropagationDirectedGraph": QgsProcessing.TEMPORARY_OUTPUT,
                },
                context=context,
                feedback=feedback,
                is_child_algorithm=True,
            )
            context.addLayerToLoadOnCompletion(
                msg_out["PropagationDirectedGraph"],
                QgsProcessingContext.LayerDetails(
                    "propagation_directed_graph",
                    context.project(),
                    "messages",
                    QgsProcessingUtils.LayerHint.Vector,
                ),
            )
        # context.temporaryLayerStore().addMapLayer(lyr_out)
        # lyr_out_str = msg_out["PropagationDirectedGraph"]
        # lyr_out = context.takeResultLayer(lyr_out_str)
        # context.addLayerToLoadOnCompletion(
        #     lyr_out_str, QgsProcessingContext.LayerDetails("messages", QgsProject.instance(), "")
        # )
        return {self.OUTPUT_DIR: str(output_directory), "MSG_OUT": msg_out, "IGNITIONS": dest_id}

    def name(self):
        return "simulationresultsprocessing"

    def displayName(self):
        return self.tr("All together bundle")

    def group(self):
        return self.tr("Simulator Post Processing")

    def groupId(self):
        return "simulatorpostprocessing"

    def tr(self, string):
        return QCoreApplication.translate("Processing", string)

    def createInstance(self):
        return PostSimulationAlgorithm()


class MessagesSIMPP(QgsProcessingAlgorithm):
    """Messages Simulation Post Processing Algorithm"""

    BASE_LAYER = "BaseLayer"
    IN_MSG = "SampleMessagesFile"
    OUTPUT_LAYER = "PropagationDirectedGraph"

    def checkParameterValues(self, parameters: dict[str, Any], context: QgsProcessingContext) -> tuple[bool, str]:
        files, msg_dir, msg_name, ext = get_files(Path(self.parameterAsString(parameters, self.IN_MSG, context)))
        if files == []:
            return False, f"{msg_dir} does not contain any non-empty '{msg_name}[0-9]*.{ext}' files"
        return True, ""

    def initAlgorithm(self, config):
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                name=self.BASE_LAYER,
                description=self.tr("Base raster (normally fuel or elevation) to get the geotransform"),
                defaultValue=[QgsProcessing.TypeRaster],
                optional=False,
            )
        )
        self.addParameter(
            QgsProcessingParameterFile(
                name=self.IN_MSG,
                description=(
                    "Sample Messages file (normally firesim_yymmdd_HHMMSS/results/Messages/MessagesFile01.csv)\nAll"
                    " ChosenName[0-9]*.csv files will be loaded"
                ),
                behavior=QgsProcessingParameterFile.File,
                extension="csv",
                defaultValue=None,
                optional=False,
            )
        )
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                name=self.OUTPUT_LAYER,
                description=self.tr("Output propagation digraph layer"),
                type=QgsProcessing.TypeVectorLine,
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        """Here is where the processing itself takes place."""
        # BASE LAYER
        base_raster = self.parameterAsRasterLayer(parameters, self.BASE_LAYER, context)
        _, raster_props = read_raster(base_raster.publicSource(), data=False)
        feedback.pushDebugInfo(f"base_raster.crs(): {base_raster.crs()}")
        GT = raster_props["Transform"]
        W = raster_props["RasterXSize"]
        H = raster_props["RasterYSize"]
        # set output layer
        fields = QgsFields()
        fields.append(QgsField(name="simulation", type=QVariant.Int, len=10))
        fields.append(QgsField(name="time", type=QVariant.Int, len=10))
        # TODO remove (,)
        (sink, dest_id) = self.parameterAsSink(
            parameters,
            self.OUTPUT_LAYER,
            context,
            fields,
            Qgis.WkbType.MultiLineString,
            base_raster.crs(),
        )
        # get messages
        files, msg_dir, msg_name, ext = get_files(Path(self.parameterAsString(parameters, self.IN_MSG, context)))
        if files == []:
            feedback.reportError(f"{msg_dir} does not contain any non-empty '{msg_name}[0-9]*{ext}' files")
            raise QgsProcessingException(f"{msg_dir} does not contain any non-empty '{msg_name}[0-9]*{ext}' files")
        feedback.pushDebugInfo(f"{len(files)} messages files, first: {files[0]}...")
        # build digraphs
        for count, afile in enumerate(files):
            sim_id = search("\\d+", afile.stem).group(0)
            data = loadtxt(afile, delimiter=",", dtype=int32, usecols=(0, 1, 2), ndmin=2)
            feedback.pushDebugInfo(f"simulation id: {sim_id}, edges: {len(data)}")
            # build line add to sink
            for i, j, time in data:
                i_x_px, i_y_ln = id2xy(i - 1, W, H)
                i_x_geo, i_y_geo = transform_coords_to_georef(i_x_px + 0.5, i_y_ln + 0.5, GT)
                # feedback.pushDebugInfo(f"i_x_geo, i_y_geo: {i_x_geo}, {i_y_geo}, time: {time}")
                j_x_px, j_y_ln = id2xy(j - 1, W, H)
                j_x_geo, j_y_geo = transform_coords_to_georef(j_x_px + 0.5, j_y_ln + 0.5, GT)
                # feedback.pushDebugInfo(f"j_x_geo, j_y_geo: {j_x_geo}, {j_y_geo}, time: {time}")
                # TODO id = int(f"{str(sim_id).zfill(total_sims)}_{i.zfill...}_{j}")
                feature = QgsFeature(fields)
                # feature.setId(int(sim_id))
                feature.setAttributes([int(sim_id), int(time)])
                feature.setGeometry(QgsLineString([QgsPoint(i_x_geo, i_y_geo), QgsPoint(j_x_geo, j_y_geo)]))
                sink.addFeature(feature, QgsFeatureSink.FastInsert)
                # feedback.pushDebugInfo(f"j_x_geo, j_y_geo: {j_x_geo}, {j_y_geo}, time: {time}, sim_idx: {sim_idx}")
                if feedback.isCanceled():
                    break
            feedback.setProgress(int(count * len(files)))

        if context.willLoadLayerOnCompletion(dest_id):
            layer = QgsProcessingUtils.mapLayerFromString(dest_id, context)
            layer_details = context.LayerDetails(
                layer.name(), context.project(), dest_id, QgsProcessingUtils.LayerHint.Vector
            )
            layer_details.groupName = NAME["layer_group"]
            layer_details.layerSortKey = 1
            context.addLayerToLoadOnCompletion(dest_id, layer_details)
            context.layerToLoadOnCompletionDetails(dest_id).setPostProcessor(run_alg_styler_propagation())

        return {self.OUTPUT_LAYER: dest_id}

    # def postProcessAlgorithm(self, context, feedback):
    #     """Called after processAlgorithm, use it to load the layer and set the symbology"""
    #     feedback.pushDebugInfo(f"postProcessAlgorithm start {context}")
    #     # layer = QgsProcessingUtils.mapLayerFromString(self.dest_id, context)
    #     layer = context.getMapLayer(self.dest_id)
    #     layer.loadNamedStyle(str(Path(assets_dir, "messages.qml")))
    #     # layer.triggerRepaint()
    #     return {self.OUTPUT_LAYER: self.dest_id}

    def tr(self, string):
        return QCoreApplication.translate("Processing", string)

    def createInstance(self):
        return MessagesSIMPP()

    def group(self):
        return self.tr("Simulator Post Processing")

    def groupId(self):
        return "simulatorpostprocessing"

    def name(self):
        return "propagationdigraph"

    def displayName(self):
        return self.tr("Propagation DiGraph")


class StatisticSIMPP(QgsProcessingAlgorithm):
    """Statistic Simulation Post Processing Algorithm"""

    IN_STAT = "SampleStatisticFile"
    BASE_LAYER = "BaseLayer"
    DATA_TYPE = "DataType"
    OUTPUT_RASTER = "OutputRaster"
    OUTPUT_RASTER_2 = "OutputRasterStats"
    gdal_dt = [GDT_Float32, GDT_Int16]
    numpy_dt = [float32, int16]
    dt_string = ["float32", "int16"]

    def checkParameterValues(self, parameters: dict[str, Any], context: QgsProcessingContext) -> tuple[bool, str]:
        files, stat_dir, stat_name, ext = get_files(Path(self.parameterAsString(parameters, self.IN_STAT, context)))
        if files == []:
            return False, f"{stat_dir} does not contain any non-empty '{stat_name}[0-9]*{ext}' files"
        return True, ""

    def initAlgorithm(self, config):
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                name=self.BASE_LAYER,
                description=self.tr("Base raster (normally fuel or elevation) to get the geotransform"),
                defaultValue=[QgsProcessing.TypeRaster],
                optional=False,
            )
        )
        known = [item["dir"] + sep + item["file"] for item in STATS]
        self.addParameter(
            QgsProcessingParameterFile(
                name=self.IN_STAT,
                description=(
                    "Sample Spatial Statistic file (normally"
                    " firesim_yymmdd_HHMMSS/results/Statistic/statistic.asc)\nAll ChosenName[0-9]*.asc files will be"
                    " loaded\nKnown: "
                )
                + ", ".join(known),
                behavior=QgsProcessingParameterFile.File,
                extension="asc",
                defaultValue=None,
                optional=False,
            )
        )
        qppe = QgsProcessingParameterEnum(
            name=self.DATA_TYPE,
            description=self.tr(
                "data type\nSpeed-up processing and lower memory requirements by casting to integers\n(Crown is"
                " integer)"
            ),
            options=self.dt_string,
            allowMultiple=False,
            defaultValue="float32",
            optional=False,
            usesStaticStrings=False,
        )
        qppe.setFlags(qppe.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        self.addParameter(qppe)
        self.addParameter(
            QgsProcessingParameterRasterDestination(
                name=self.OUTPUT_RASTER,
                description=self.tr("Output raster"),
                # defaultValue=None,
                # optional=False,
                # createByDefault=True,
            )
        )
        self.addParameter(
            QgsProcessingParameterRasterDestination(
                name=self.OUTPUT_RASTER_2,
                description=self.tr("Output raster mean & std"),
                # defaultValue=None,
                optional=True,
                createByDefault=True,
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        """proc algo"""
        feedback.pushDebugInfo(f"processAlgorithm start, parameters: {parameters}, type: {type(parameters)}")
        # get base map
        base_raster = self.parameterAsRasterLayer(parameters, self.BASE_LAYER, context)
        _, raster_props = read_raster(base_raster.publicSource(), data=False)
        feedback.pushDebugInfo(f"base_raster.crs(): {base_raster.crs()}")
        GT = raster_props["Transform"]
        W = raster_props["RasterXSize"]
        H = raster_props["RasterYSize"]
        # get data
        files, stat_dir, stat_name, ext = get_files(Path(self.parameterAsString(parameters, self.IN_STAT, context)))
        if files == []:
            feedback.reportError(f"{stat_dir} does not contain any non-empty '{stat_name}[0-9]*{ext}' files")
            raise QgsProcessingException(f"{stat_dir} does not contain any non-empty '{stat_name}[0-9]*{ext}' files")
        feedback.pushDebugInfo(f"{len(files)} files, first: {files[0]}...")
        # infer dimensional units
        if unit := [item["unit"] for item in STATS if item["file"] == stat_name]:
            unit = unit[0]
        else:
            unit = None
        # out raster
        output_raster_filename = self.parameterAsOutputLayer(parameters, self.OUTPUT_RASTER, context)
        raster_format = Grass7Utils.getRasterFormatFromFilename(output_raster_filename)
        feedback.pushDebugInfo(f"output_raster: {output_raster_filename}, {raster_format}")
        # dtype
        data_type_idx = self.parameterAsEnum(parameters, self.DATA_TYPE, context)
        feedback.pushDebugInfo(
            f"data_type_idx: {data_type_idx}, {self.gdal_dt[data_type_idx]}, {self.numpy_dt[data_type_idx]}"
        )
        # create
        dst_ds = gdal.GetDriverByName(raster_format).Create(
            output_raster_filename, W, H, len(files), self.gdal_dt[data_type_idx]
        )
        dst_ds.SetGeoTransform(GT)  # specify coords
        dst_ds.SetProjection(base_raster.crs().authid())  # export coords to file

        # colors = get_color_table(feedback, cm = colormaps.get('magma'))
        data = []
        for count, afile in enumerate(files):
            sim_id = search("\\d+", afile.stem).group(0)
            data += [loadtxt(afile, dtype=self.numpy_dt[data_type_idx], skiprows=6)]
            feedback.pushDebugInfo(f"simulation id: {sim_id}, data: {data[-1].shape}")
            band = dst_ds.GetRasterBand(count + 1)
            # if 0 != band.SetDescription(f"simulation id: {sim_id}"):
            #     feedback.pushWarning(f"SetDescription failed for {band}")
            # TODO
            # r"""SetUnitType(Band self, char const * val) -> CPLErr"""
            if unit:
                band.SetUnitType(unit)
            # r"""SetStatistics(Band self, double min, double max, double mean, double stddev) -> CPLErr"""
            # NOT THIS : band.SetStatistics(data[-1].min(), data[-1].max(), data[-1].mean(), data[-1].std())
            # r"""SetCategoryNames(Band self, char ** papszCategoryNames) -> CPLErr"""
            # band.SetCategoryNames(["min", "max", "mean", "stddev"])
            # ds.SetMetadata({"X_BAND": "1" }, "GEOLOCATION")
            # band.SetCategoryNames([f"simulation id: {sim_idx}"])
            # colors = get_color_table(feedback, data[-1].min(), data[-1].max(), cm=colormaps.get("magma"))
            # feedback.pushDebugInfo(f"colors: {colors} {colors.GetCount()}, {data[-1].min()}, {data[-1].max()}")
            # if 0 != band.SetRasterColorInterpretation(GCI_PaletteIndex):
            #     feedback.pushWarning(f"SetRasterColorInterpretation failed for {band}")
            # if 0 != band.SetRasterColorTable(colors):
            #     feedback.pushWarning(f"SetRasterColorTable failed for {band}")
            if 0 != band.SetNoDataValue(0):
                feedback.pushWarning(f"Set No Data failed for {afile}")
            if 0 != band.WriteArray(data[-1]):
                feedback.pushWarning(f"WriteArray failed for {afile}")
            if feedback.isCanceled():
                break
            # band.FlushCache()  # write to disk
            # band = None
            # colors = None
            feedback.setProgress(int(count * len(files)))
        data = array(data)
        dst_ds.FlushCache()  # write to disk
        dst_ds = None
        if context.willLoadLayerOnCompletion(output_raster_filename):
            # attach post processor
            display_name = f"{stat_name}_{self.numpy_dt[data_type_idx].__name__}"
            layer_details = context.LayerDetails(display_name, context.project(), display_name, QgsProcessingUtils.LayerHint.Raster)
            layer_details.groupName = NAME["layer_group"]
            layer_details.layerSortKey = 2
            context.addLayerToLoadOnCompletion(output_raster_filename, layer_details)
            context.layerToLoadOnCompletionDetails(output_raster_filename).setPostProcessor(
                run_alg_styler(
                    display_name,
                    layer_min_val=data.min(),
                    layer_max_val=data.max(),
                    layer_bands=len(files) + 1,
                )
            )
        output_dict = {self.OUTPUT_RASTER: output_raster_filename}

        if len(files) > 1:
            # out raster
            output_raster2_filename = self.parameterAsOutputLayer(parameters, self.OUTPUT_RASTER_2, context)
            raster_format2 = Grass7Utils.getRasterFormatFromFilename(output_raster2_filename)
            feedback.pushDebugInfo(f"output_raster2: {output_raster2_filename}, {raster_format2}")
            # create
            dst_ds2 = gdal.GetDriverByName(raster_format2).Create(
                output_raster2_filename, W, H, 2, self.gdal_dt[data_type_idx]
            )
            dst_ds2.SetGeoTransform(GT)  # specify coords
            dst_ds2.SetProjection(base_raster.crs().authid())  # export coords to file
            band = dst_ds2.GetRasterBand(1)
            # mean
            band = dst_ds2.GetRasterBand(1)
            if 0 != band.SetNoDataValue(0):
                feedback.pushWarning(f"Set No Data failed for mean band")
            if 0 != band.WriteArray(data.mean(axis=0)):
                feedback.pushWarning(f"WriteArray failed for mean band")
            # std
            band = dst_ds2.GetRasterBand(2)
            if 0 != band.SetNoDataValue(0):
                feedback.pushWarning(f"Set No Data failed for mean band")
            if 0 != band.WriteArray(data.std(axis=0)):
                feedback.pushWarning(f"WriteArray failed for mean band")
            dst_ds2.FlushCache()  # write to disk
            dst_ds2 = None
            output_dict[self.OUTPUT_RASTER_2] = output_raster2_filename
            # rename if showing
            if context.willLoadLayerOnCompletion(output_raster2_filename):
                layer_details = context.layerToLoadOnCompletionDetails(output_raster2_filename)
                layer_details.name = f"{stat_name}_mean&std_{self.numpy_dt[data_type_idx].__name__}"
                layer_details.groupName = NAME["layer_group"]
                layer_details.layerSortKey = 3
        else:
            output_dict[self.OUTPUT_RASTER_2] = None
        feedback.pushDebugInfo(f"finished")

        return output_dict

    # def postProcessAlgorithm(self, context, feedback):
    #     """Called after processAlgorithm, use it to load the layer and set the symbology"""
    #     feedback.pushDebugInfo(f"postProcessAlgorithm start {context}")
    #     # layer = QgsProcessingUtils.mapLayerFromString(self.dest_id, context)
    #     layer = context.getMapLayer(self.dest_id)
    #     layer.loadNamedStyle(str(Path(assets_dir, "messages.qml")))
    #     # layer.triggerRepaint()
    #     return {self.OUTPUT_LAYER: self.dest_id}

    def tr(self, string):
        return QCoreApplication.translate("Processing", string)

    def createInstance(self):
        return StatisticSIMPP()

    def group(self):
        return self.tr("Simulator Post Processing")

    def groupId(self):
        return "simulatorpostprocessing"

    def name(self):
        return "statistic"

    def displayName(self):
        return self.tr("Spatial Statistic")


class ScarSIMPP(QgsProcessingAlgorithm):
    """Fire scar Simulation Post Processing Algorithm"""

    IN_SCAR = "SampleScarFile"
    BASE_LAYER = "BaseLayer"
    OUTPUT_RASTER = "OutputRaster"

    def checkParameterValues(self, parameters: dict[str, Any], context: QgsProcessingContext) -> tuple[bool, str]:
        files, scar_dir, scar_name, ext = get_scar_files(
            Path(self.parameterAsString(parameters, self.IN_SCAR, context))
        )
        if files == []:
            return False, f"{scar_dir} does not contain any non-empty '{scar_name}[0-9]*{ext}' files"
        return True, ""

    def initAlgorithm(self, config):
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                name=self.BASE_LAYER,
                description=self.tr("Base raster (normally fuel or elevation) to get the geotransform"),
                defaultValue=[QgsProcessing.TypeRaster],
                optional=False,
            )
        )
        self.addParameter(
            QgsProcessingParameterFile(
                name=self.IN_SCAR,
                description=(
                    "Sample Fire Scar file (normally"
                    " firesim_yymmdd_HHMMSS/results/Grids/Grids[0-9]*/ForestGrid[0-9]*.csv)"
                ),
                behavior=QgsProcessingParameterFile.File,
                extension="csv",
                defaultValue=None,
                optional=False,
            )
        )
        self.addParameter(
            QgsProcessingParameterRasterDestination(
                name=self.OUTPUT_RASTER,
                description=self.tr("Output raster"),
                # defaultValue=None,
                # optional=False,
                # createByDefault=True,
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        """Here is where the processing itself takes place."""
        feedback.pushDebugInfo("processAlgorithm start")
        # get base map
        base_raster = self.parameterAsRasterLayer(parameters, self.BASE_LAYER, context)
        _, raster_props = read_raster(base_raster.publicSource(), data=False)
        feedback.pushDebugInfo(f"base_raster.crs(): {base_raster.crs()}")
        GT = raster_props["Transform"]
        W = raster_props["RasterXSize"]
        H = raster_props["RasterYSize"]
        # get IN_SCAR -> grids, final_grids
        sample_file = Path(self.parameterAsString(parameters, self.IN_SCAR, context))
        ext = sample_file.suffix
        if numg := search("(\\d+)$", sample_file.stem):
            num = numg.group()
        else:
            raise ValueError(f"sample_file: {sample_file} does not contain a number at the end")
        file_name = sample_file.stem[: -len(num)]
        parent1 = sample_file.absolute().parent
        parent2 = sample_file.absolute().parent.parent
        if numg := search("(\\d+)$", parent1.name):
            num = numg.group()
        else:
            raise ValueError(f"sample_file: {sample_file} does not contain a number at the end")
        parent1name = parent1.name[: -len(num)]
        file_gen = parent2.rglob(parent1name + "[0-9]*" + sep + file_name + "[0-9]*" + ext)
        files = []
        sim_id = []
        per_id = []
        for afile in file_gen:
            if afile.is_file() and afile.stat().st_size > 0:
                print("afile", afile, afile.parent.name, afile.stem)
                files += [afile.relative_to(parent2)]
                sim_id += [search("(\\d+)$", str(afile.parent.name)).group()]
                per_id += [search("(\\d+)$", str(afile.stem)).group()]
        feedback.pushDebugInfo(f"files[:3]: {files[:3]}, parent: {parent2}, name: {file_name}, ext: {ext}")
        files = array(files)
        sim_id = array(sim_id, dtype=int32)
        per_id = array(per_id, dtype=int32)
        # unique sorts
        simulations = unique(sim_id)
        # files,sim_id,per_id
        grids = []
        final_grids = []
        for s in simulations:
            sim_files = files[sim_id == s]
            sim_periods = per_id[sim_id == s]
            # final
            final_grids += [[sim_files[sim_periods.argmax()], s, sim_periods.max()]]
            # sort
            sorted_periods = argsort(sim_periods)
            grids += [[sim_files[sorted_periods], s, sim_periods[sorted_periods]]]
        # feedback.pushDebugInfo(f"final_grids: {final_grids}")
        # feedback.pushDebugInfo(f"grids: {grids}")

        # raster
        output_raster_filename = self.parameterAsOutputLayer(parameters, self.OUTPUT_RASTER, context)
        raster_format = Grass7Utils.getRasterFormatFromFilename(output_raster_filename)
        feedback.pushDebugInfo(f"output_raster: {output_raster_filename}, {raster_format}")

        dst_ds = gdal.GetDriverByName(raster_format).Create(
            output_raster_filename, W, H, len(final_grids), GDT_Int16
        )  #  + 1 bands?
        dst_ds.SetGeoTransform(GT)  # specify coords
        dst_ds.SetProjection(base_raster.crs().authid())  # export coords to file

        feedback.setProgressText(f"Processing final scars {len(final_grids)} files")
        data = []
        for i, (afile, sim, per) in enumerate(final_grids):
            feedback.pushDebugInfo(f"simulation id: {sim}, period: {per}, file: {afile}")
            data += [loadtxt(Path(parent2, afile), delimiter=",", dtype=int16)]
            band = dst_ds.GetRasterBand(i + 1)
            band.SetUnitType("burned")
            if 0 != band.SetNoDataValue(0):
                feedback.pushWarning(f"Set No Data failed for {afile}")
            if 0 != band.WriteArray(data[-1]):
                feedback.pushWarning(f"WriteArray failed for {afile}")
            if feedback.isCanceled():
                break
            feedback.setProgress(int(i * len(final_grids)))
        data = array(data)
        dst_ds.FlushCache()  # write to disk
        dst_ds = None
        # rename if showing
        if context.willLoadLayerOnCompletion(output_raster_filename):
            layer_details = context.layerToLoadOnCompletionDetails(output_raster_filename)
            layer_details.setPostProcessor(run_alg_styler_bin("Final Scar(s)"))
            layer_details.groupName = NAME["layer_group"]
        feedback.pushDebugInfo(f"propagation final scar finished")

        # TODO
        # msg = f"Processing propagation scars {len(grids)} files"
        # feedback.setProgressText(msg)
        # feedback.pushDebugInfo(msg)
        # orfnp = Path(output_raster_filename)
        # name, suffix = orfnp.stem, orfnp.suffix
        # layer_details = []
        # for i, (files, sim, pers) in enumerate(grids):
        #     feedback.setProgress(int(i * len(final_grids)))
        #     file_name = name + "_propagation_" + str(sim) + suffix
        #     dst_ds = gdal.GetDriverByName(raster_format).Create(file_name, W, H, len(files), GDT_Int16)
        #     dst_ds.SetGeoTransform(GT)  # specify coords
        #     dst_ds.SetProjection(base_raster.crs().authid())  # export coords to file
        #     for j, (afile, per) in enumerate(zip(files, pers)):
        #         feedback.pushDebugInfo(f"simulation id: {sim}, period: {per}, file: {afile}")
        #         data = loadtxt(Path(parent2, afile), delimiter=",", dtype=int16)
        #         if not any(data == 1):
        #             feedback.pushWarning(f"no fire in {afile} warning! TODO?")
        #         band = dst_ds.GetRasterBand(j + 1)
        #         band.SetUnitType("burned")
        #         if 0 != band.SetNoDataValue(0):
        #             feedback.pushWarning(f"Set No Data failed for {afile}")
        #         if 0 != band.WriteArray(data):
        #             feedback.pushWarning(f"WriteArray failed for {afile}")
        #         if feedback.isCanceled():
        #             break
        #         band = None
        #         data = None
        #     dst_ds.FlushCache()  # write to disk
        #     dst_ds = None
        #     layer_name = f"propagation_{sim}"
        #     layer_details += [
        #         QgsProcessingContext.LayerDetails(
        #             file_name, context.project(), file_name, QgsProcessingUtils.LayerHint.Raster
        #         )
        #     ]
        #     layer_details[-1].groupName = NAME["layer_group"]
        #     layer_details[-1].setPostProcessor(run_alg_styler_bin(layer_name))
        #     context.addLayerToLoadOnCompletion(file_name, layer_details[-1])

        feedback.pushDebugInfo(f"finished")
        return {self.OUTPUT_RASTER: output_raster_filename}

    def name(self):
        return "scar"

    def displayName(self):
        return self.tr("Fire Scar")

    def group(self):
        return self.tr("Simulator Post Processing")

    def groupId(self):
        return "simulatorpostprocessing"

    def tr(self, string):
        return QCoreApplication.translate("Processing", string)

    def createInstance(self):
        return ScarSIMPP()


def run_alg_styler_propagation():
    """Create a New Post Processor class and returns it"""

    class LayerPostProcessor(QgsProcessingLayerPostProcessorInterface):
        instance = None

        def postProcessLayer(self, layer, context, feedback):
            if layer.isValid():
                processing.run(
                    "qgis:setstyleforvectorlayer",
                    {"INPUT": layer, "STYLE": str(Path(assets_dir, "messages.qml"))},
                    context=context,
                    feedback=feedback,
                    is_child_algorithm=True,
                )
                renderer = layer.renderer()
                renderer.updateClasses(layer, QgsGraduatedSymbolRenderer.Mode.Jenks, 10)
                # enum : EqualInterval , Quantile , Jenks , StdDev , Pretty , Custom
                # layer.triggerRepaint()
            else:
                feedback.pushInfo(f"Layer not valid: {self.name}")

        # Hack to work around sip bug!
        @staticmethod
        def create() -> "LayerPostProcessor":
            LayerPostProcessor.instance = LayerPostProcessor()
            return LayerPostProcessor.instance

    return LayerPostProcessor.create()


def run_alg_styler_bin(display_name, layer_bands=1):
    """Create a New Post Processor class and returns it"""

    class LayerPostProcessor(QgsProcessingLayerPostProcessorInterface):
        instance = None
        name = display_name
        bands = layer_bands

        lst = [
            QgsColorRampShader.ColorRampItem(0, QColor(2, 2, 2)),
            QgsColorRampShader.ColorRampItem(1, QColor(222, 222, 222)),
        ]
        class_data = QgsPalettedRasterRenderer.colorTableToClassData(lst)  # <-

        def postProcessLayer(self, layer, context, feedback):
            feedback.pushInfo(f"Inside postProcessLayer: {self.name}")
            if layer.isValid():
                prov = layer.dataProvider()
                layer.setName(self.name)
                feedback.pushInfo(f"Layer valid, set name: {self.name}")
                for band in range(1, self.bands + 1):
                    renderer = QgsPalettedRasterRenderer(prov, band, self.class_data)
                    layer.setRenderer(renderer)
            else:
                feedback.pushInfo(f"Layer not valid: {self.name}")

        # Hack to work around sip bug!
        @staticmethod
        def create() -> "LayerPostProcessor":
            LayerPostProcessor.instance = LayerPostProcessor()
            return LayerPostProcessor.instance

    return LayerPostProcessor.create()


def run_alg_styler(
    display_name, layer_color1=(68, 1, 84), layer_color2=(253, 231, 37), layer_min_val=0, layer_max_val=1, layer_bands=1
):
    """Create a New Post Processor class and returns it

    # Just simply creating a new instance of the class was not working
    # for details see https://gis.stackexchange.com/questions/423650/qgsprocessinglayerpostprocessorinterface-only-processing-the-last-layer
    """

    class LayerPostProcessor(QgsProcessingLayerPostProcessorInterface):
        instance = None
        name = display_name
        color1 = layer_color1
        color2 = layer_color2
        min_val = layer_min_val
        max_val = layer_max_val
        bands = layer_bands

        def postProcessLayer(self, layer, context, feedback):
            feedback.pushInfo(f"Inside postProcessLayer: {self.name}")
            if layer.isValid():
                prov = layer.dataProvider()
                # stats = prov.bandStatistics(1, QgsRasterBandStats.All, layer.extent(), 0)
                # min_value = stats.minimumValue
                # max_value = stats.maximumValue
                feedback.pushInfo(f"Layer valid: {self.name}")
                layer.setName(self.name)
                for band in range(1, self.bands + 1)[::-1]:
                    fcn = QgsColorRampShader()
                    fcn.setColorRampType(QgsColorRampShader.Interpolated)
                    lst = [
                        QgsColorRampShader.ColorRampItem(self.min_val, QColor(*self.color1)),
                        QgsColorRampShader.ColorRampItem(self.max_val, QColor(*self.color2)),
                    ]
                    fcn.setColorRampItemList(lst)
                    shader = QgsRasterShader()
                    shader.setRasterShaderFunction(fcn)
                    # windows error argument 1 has unexpected type 'QgsMeshDataProvider'
                    renderer = QgsSingleBandPseudoColorRenderer(prov, band, shader)
                    layer.setRenderer(renderer)
                # renderer = QgsSingleBandPseudoColorRenderer(layer.dataProvider(), 1, shader)
                # layer.setRenderer(renderer)
            else:
                feedback.pushInfo(f"Layer not valid: {self.name}")

        # Hack to work around sip bug!
        @staticmethod
        def create() -> "LayerPostProcessor":
            LayerPostProcessor.instance = LayerPostProcessor()
            return LayerPostProcessor.instance

    return LayerPostProcessor.create()


def get_files(sample_file: Path) -> list[list[Path], Path, str, str]:
    """Get a list of files with the same name (+ any digit) and extension and the directory and name of the sample file"""
    ext = sample_file.suffix
    if numg := search("(\\d+)$", sample_file.stem):
        num = numg.group()
    else:
        raise ValueError(f"sample_file: {sample_file} does not contain a number at the end")
    aname = sample_file.stem[: -len(num)]
    adir = sample_file.absolute().parent
    files = []
    for afile in sorted(adir.glob(aname + "[0-9]*" + ext)):
        if afile.is_file() and afile.stat().st_size > 0:
            files += [afile]
    # QgsMessageLog.logMessage(f"files: {files}, adir: {adir}, aname: {aname}, ext: {ext}", "fire2a", Qgis.Info)
    return files, adir, aname, ext


def get_scar_files(sample_file: Path) -> list[list[Path], Path, str, str]:
    """Get a list of files with the same name (+ any digit) and extension and the directory and name of the sample file
    sample_file = Path('/home/fdo/source/C2F-W/data/Vilopriu_2013/firesim_231001_145657/results/Grids/Grids1/ForestGrid00.csv')
    """
    ext = sample_file.suffix
    if numg := search("(\\d+)$", sample_file.stem):
        num = numg.group()
    else:
        raise ValueError(f"sample_file: {sample_file} does not contain a number at the end")
    file_name = sample_file.stem[: -len(num)]
    parent1 = sample_file.absolute().parent
    parent2 = sample_file.absolute().parent.parent
    if numg := search("(\\d+)$", parent1.name):
        num = numg.group()
    else:
        raise ValueError(f"sample_file: {sample_file} does not contain a number at the end")
    parent1name = parent1.name[: -len(num)]
    file_gen = parent2.rglob(parent1name + "[0-9]*" + sep + file_name + "[0-9]*" + ext)
    files = []
    for afile in sorted(file_gen):
        if afile.is_file() and afile.stat().st_size > 0:
            files += [afile.relative_to(parent2)]
    # QgsMessageLog.logMessage(f"files: {files}, adir: {adir}, aname: {aname}, ext: {ext}", "fire2a", Qgis.Info)
    return files, parent2, file_name, ext
