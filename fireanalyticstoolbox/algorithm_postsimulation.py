# -*- coding: utf-8 -*-

"""
/***************************************************************************
 FireToolbox
                                 A QGIS plugin
 A collection of fire insights related algorithms
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-08-30
        copyright            : (C) 2023 by Fernando Badilla Veliz - Fire2a.com
        email                : fbadilla@ing.uchile.cl
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
TODO:
    group results https://gis.stackexchange.com/questions/416542/adding-output-layers-of-qgis-processing-scripts-to-group-using-pyqgis
util:
    https://gis.stackexchange.com/questions/314036/programmatically-styling-layer-after-output-is-returned-from-qgis-3-processing-s
    https://lists.osgeo.org/pipermail/qgis-developer/2021-June/063741.html
    https://gis.stackexchange.com/questions/375987/customizing-qgsprocessing-output-layer-name
    https://gis.stackexchange.com/questions/448603/change-the-symbology-of-a-vector-output-layer-that-is-returned-from-a-processing
    https://gis.stackexchange.com/questions/414559/qgis-iterative-rasterize-naming
    https://gis.stackexchange.com/questions/306659/pyqgis-style-layer-after-processing-with-qml-file

"""

__author__ = "Fernando Badilla Veliz - Fire2a.com"
__date__ = "2023-08-30"
__copyright__ = "(C) 2023 by Fernando Badilla Veliz - Fire2a.com"

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = "$Format:%H$"

from pathlib import Path
from re import findall, search
from typing import Any

import processing
from fire2a.raster import get_geotransform, id2xy, read_raster, transform_coords_to_georef
from grassprovider.Grass7Utils import Grass7Utils
from matplotlib import colormaps
from matplotlib.colors import to_rgba_array
from numpy import array, dtype, float32, fromiter, int16, int32, linspace, loadtxt
from osgeo import gdal
from osgeo.gdal import GA_ReadOnly, GCI_PaletteIndex, GDT_Float32, GDT_Int16
from qgis.core import (Qgis, QgsApplication, QgsColorRampShader, QgsFeature, QgsFeatureSink, QgsField, QgsFields,
                       QgsGeometry, QgsGradientColorRamp, QgsLineString, QgsMessageLog, QgsPoint, QgsProcessing,
                       QgsProcessingAlgorithm, QgsProcessingContext, QgsProcessingException,
                       QgsProcessingLayerPostProcessorInterface, QgsProcessingParameterBoolean,
                       QgsProcessingParameterDefinition, QgsProcessingParameterEnum, QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterFile, QgsProcessingParameterFolderDestination,
                       QgsProcessingParameterNumber, QgsProcessingParameterRasterDestination,
                       QgsProcessingParameterRasterLayer, QgsProcessingParameterString,
                       QgsProcessingParameterVectorLayer, QgsProject, QgsRasterBandStats, QgsRasterLayer,
                       QgsRasterShader, QgsSingleBandPseudoColorRenderer, QgsTask, QgsVectorLayer)
from qgis.PyQt.QtCore import QCoreApplication, QVariant
from qgis.PyQt.QtGui import QColor

plugin_dir = Path(__file__).parent
assets_dir = Path(plugin_dir, "simulator")


class PostSimulationAlgorithm(QgsProcessingAlgorithm):
    """Cell2Fire results post processing bundle"""

    INSTANCE_DIR = "InstanceDirectory"
    BASE_LAYER = "BaseLayer"
    RESULTS_DIR = "ResultsDirectory"
    OUTPUTS = "RequestedOutputs"
    OUTPUT_DIR = "OutputFolder"
    IGNI_POINTS = "IgnitionPointsLayer"
    output_options = [
        "Final fire scar",
        "Propagation fire scars",
        "Propagation directed-graph",
        "Hit rate of spread",
        "Flame Length",
        "Byram Intensity",
        "Crown Fire Scar",
        "Crown Fire Fuel Consumption",
        # "Betweenness Centrality",
        # "Downstream Protection Value",
    ]

    def initAlgorithm(self, config):
        """inputs and output of the algorithm"""
        project_path = QgsProject().instance().absolutePath()
        self.addParameter(
            QgsProcessingParameterFile(
                name=self.INSTANCE_DIR,
                description="Cell2 Fire Simulator INSTANCE directory (normally firesim_yymmdd_HHMMSS)",
                behavior=QgsProcessingParameterFile.Folder,
                extension="",
                defaultValue=project_path if project_path != "" else None,
                optional=False,
                fileFilter="",
            )
        )
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                name=self.BASE_LAYER,
                description=self.tr(
                    "Base raster (normally fuel or elevation) to get the geotransform, optional.\n If not provided, a"
                    " raster in the instance directory will be used"
                ),
                defaultValue=[QgsProcessing.TypeRaster],
                optional=True,
            )
        )
        self.addParameter(
            QgsProcessingParameterFile(
                name=self.RESULTS_DIR,
                description="Cell2 Fire Simulator RESULTS directory (normally firesim_yymmdd_HHMMSS/results)",
                behavior=QgsProcessingParameterFile.Folder,
                extension="",
                defaultValue=project_path if project_path != "" else None,
                optional=False,
                fileFilter="",
            )
        )
        self.addParameter(
            QgsProcessingParameterEnum(
                name=self.OUTPUTS,
                description=self.tr("Requested Options (subset of requested for simulation)"),
                options=self.output_options,
                allowMultiple=True,
                defaultValue=list(range(len(self.output_options))),
            )
        )
        self.addParameter(
            QgsProcessingParameterFolderDestination(
                name=self.OUTPUT_DIR,
                description="Output directory",
                defaultValue=None,
                optional=True,
                createByDefault=True,
            )
        )
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                name=self.IGNI_POINTS,
                description=self.tr("Output ignition points layer"),
                type=QgsProcessing.TypeVectorPoint,
            )
        )

    def checkParameterValues(self, parameters: dict[str, Any], context: QgsProcessingContext) -> tuple[bool, str]:
        """log file exists and is not empty"""
        instance_directory = Path(self.parameterAsString(parameters, self.INSTANCE_DIR, context))
        fuels = Path(instance_directory, "fuels.asc")
        if not fuels.is_file() and fuels.stat().st_size > 0:
            return False, f"fuels.asc file not found or empty in instance directory: ({instance_directory})"
        results_directory = Path(self.parameterAsString(parameters, self.RESULTS_DIR, context))
        log_file = Path(results_directory, "LogFile.txt")
        if not log_file.is_file() and log_file.stat().st_size > 0:
            return False, f"LogFile.txt file not found or empty in results directory: ({results_directory})"
        return True, ""

    def processAlgorithm(self, parameters, context, feedback):
        """Here is where the processing itself takes place."""
        feedback.pushDebugInfo("processAlgorithm start")
        feedback.pushDebugInfo(f"context args: {context.asQgisProcessArguments()}")
        # feedback.pushDebugInfo(f"parameters {parameters}")
        # GET OPTIONS
        output_options = self.parameterAsEnums(parameters, self.OUTPUTS, context)
        output_options_strings = array(self.output_options)[output_options]
        feedback.pushDebugInfo(f"output_options: {output_options_strings}\n")
        # OUTPUT DIR
        output_directory = Path(self.parameterAsString(parameters, self.OUTPUT_DIR, context))
        # INSTANCE DIR
        instance_directory = Path(self.parameterAsString(parameters, self.INSTANCE_DIR, context))
        # BASE LAYER
        if base_raster := self.parameterAsRasterLayer(parameters, self.BASE_LAYER, context):
            feedback.pushDebugInfo(f"0 base_raster: {base_raster}")
        else:
            base_raster = QgsRasterLayer(str(Path(instance_directory, "fuels.asc")), "base_raster")
            feedback.pushDebugInfo(f"1 base_raster: {base_raster}")
        _, raster_props = read_raster(base_raster.publicSource(), data=False)

        # RESULTS DIR
        results_directory = Path(self.parameterAsString(parameters, self.RESULTS_DIR, context))
        # log file
        log_file = Path(results_directory, "LogFile.txt")
        log_text = log_file.read_text(encoding="utf-8")
        feedback.pushDebugInfo(log_text[:80])

        fields = QgsFields()
        fields.append(QgsField(name="simulation", type=QVariant.Int, len=10))
        fields.append(QgsField(name="cell", type=QVariant.Int, len=10))
        fields.append(QgsField(name="x_pixel", type=QVariant.Int, len=10))
        fields.append(QgsField(name="y_line", type=QVariant.Int, len=10))
        feedback.pushDebugInfo(f"base_raster.crs(): {base_raster.crs()}")
        (sink, dest_id) = self.parameterAsSink(
            parameters,
            self.IGNI_POINTS,
            context,
            fields,
            Qgis.WkbType.Point,
            base_raster.crs(),
        )
        simulation_id, ignition_cell = fromiter(
            findall("ignition point for Year [0-9]*, sim ([0-9]+): ([0-9]+)", log_text), dtype=dtype((int32, 2))
        ).T
        ignition_cell -= 1  # 1 based to 0 based
        features = []
        for sim_id, cell in zip(simulation_id, ignition_cell):
            i, j = id2xy(cell, raster_props["RasterXSize"], raster_props["RasterYSize"])
            x, y = transform_coords_to_georef(i + 0.5, j + 0.5, raster_props["Transform"])
            feature = QgsFeature(fields)
            feature.setId(int(sim_id))
            feature.setAttributes([int(sim_id), int(cell + 1), int(i), int(j)])
            feature.setGeometry(QgsGeometry(QgsPoint(x, y)))
            sink.addFeature(feature, QgsFeatureSink.FastInsert)
            feedback.pushDebugInfo(f"simulation id: {sim_id}, ignition cell: {cell}, x: {x}, y: {y}, i: {i}, j: {j}")
        feedback.pushDebugInfo(f"addFeatures: {sink}, {type(sink)}")
        processing.run(
            "qgis:setstyleforvectorlayer",
            {"INPUT": dest_id, "STYLE": str(Path(assets_dir, "ignition_points.qml"))},
            context=context,
            feedback=feedback,
            is_child_algorithm=True,
        )

        msg_out = None
        if "Propagation directed-graph" in output_options_strings:
            msg_out = processing.run(
                "fire2a:messages",
                {
                    "BaseLayer": str(Path(instance_directory, "fuels.asc")),
                    "MessagesDirectory": str(Path(results_directory, "Messages")),
                    "PropagationDirectedGraph": QgsProcessing.TEMPORARY_OUTPUT,
                },
                context=context,
                feedback=feedback,
                is_child_algorithm=True,
            )
            context.addLayerToLoadOnCompletion(
                msg_out["PropagationDirectedGraph"],
                QgsProcessingContext.LayerDetails(
                    "propagation_directed_graph",
                    context.project(),
                    "messages",
                ),
            )
        # context.temporaryLayerStore().addMapLayer(lyr_out)
        # lyr_out_str = msg_out["PropagationDirectedGraph"]
        # lyr_out = context.takeResultLayer(lyr_out_str)
        # context.addLayerToLoadOnCompletion(
        #     lyr_out_str, QgsProcessingContext.LayerDetails("messages", QgsProject.instance(), "")
        # )
        return {self.OUTPUT_DIR: str(output_directory), "MSG_OUT": msg_out, "IGNITIONS": dest_id}

    def name(self):
        return "simulationresultsprocessing"

    def displayName(self):
        return self.tr("All together bundle")

    def group(self):
        return self.tr("Simulator Post Processing")

    def groupId(self):
        return "simulatorpostprocessing"

    def tr(self, string):
        return QCoreApplication.translate("Processing", string)

    def createInstance(self):
        return PostSimulationAlgorithm()


class MessagesSIMPP(QgsProcessingAlgorithm):
    """Messages Simulation Post Processing Algorithm"""

    BASE_LAYER = "BaseLayer"
    MSGS_DIR = "MessagesDirectory"
    OUTPUT_LAYER = "PropagationDirectedGraph"

    def checkParameterValues(self, parameters: dict[str, Any], context: QgsProcessingContext) -> tuple[bool, str]:
        """log file exists and is not empty
        debug:
            output_dir = Path('/home/fdo/source/C2F-W/data/Homogeneous_kitral/firesim_230922_135815/results')
            output_dir.is_dir()
            msg_dir = Path(output_dir, "Messages")
            msg_dir.is_dir()
            not any([ afile for afile in files if afile.is_file() and afile.stat().st_size>0 ])
        """
        msg_dir = Path(self.parameterAsString(parameters, self.MSGS_DIR, context))
        if not msg_dir.is_dir():
            return False, f"Provided {self.MSGS_DIR}: {msg_dir} is not a directory"
        files = list(msg_dir.glob("MessagesFile[0-9]*.csv"))
        if files == []:
            return False, f"Provided {self.MSGS_DIR}: {msg_dir} does not contain any 'MessagesFile[0-9]*.csv' files"
        if not any([afile for afile in files if afile.is_file() and afile.stat().st_size > 0]):
            return False, f"Provided {self.MSGS_DIR}: {msg_dir} contains only empty 'MessagesFile[0-9]*.csv' file"
        return True, ""

    def initAlgorithm(self, config):
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                name=self.OUTPUT_LAYER,
                description=self.tr("Output propagation digraph layer"),
                type=QgsProcessing.TypeVectorLine,
            )
        )
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                name=self.BASE_LAYER,
                description=self.tr("Base raster (normally fuel or elevation) to get the geotransform"),
                defaultValue=[QgsProcessing.TypeRaster],
                optional=False,
            )
        )
        self.addParameter(
            QgsProcessingParameterFile(
                name=self.MSGS_DIR,
                description="Cell2 Fire Simulator Messages directory (normally firesim_yymmdd_HHMMSS/results/Messages)",
                behavior=QgsProcessingParameterFile.Folder,
                extension="",
                defaultValue=None,
                optional=False,
                fileFilter="",
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        """
        msgs_files = sorted(list(Path(output_dir, "Messages").glob("MessagesFile[0-9]*.csv")))
        """
        feedback.pushDebugInfo("processAlgorithm start")
        # get base map
        base_raster = self.parameterAsRasterLayer(parameters, self.BASE_LAYER, context)
        dataset = gdal.Open(base_raster.publicSource(), GA_ReadOnly)
        if dataset is None:
            raise FileNotFoundError(base_raster.publicSource())
        GT = dataset.GetGeoTransform()
        # "Projection": ds.GetProjection(),
        # "RasterCount": ds.RasterCount,
        W = dataset.RasterXSize
        H = dataset.RasterYSize
        # set output layer
        fields = QgsFields()
        fields.append(QgsField(name="simulation", type=QVariant.Int, len=10))
        fields.append(QgsField(name="time", type=QVariant.Int, len=10))
        feedback.pushDebugInfo(f"base_raster.crs(): {base_raster.crs()}")
        (sink, dest_id) = self.parameterAsSink(
            parameters,
            self.OUTPUT_LAYER,
            context,
            fields,
            Qgis.WkbType.MultiLineString,
            base_raster.crs(),
        )

        # get messages
        msg_dir = Path(self.parameterAsString(parameters, self.MSGS_DIR, context))
        files = []
        for afile in msg_dir.glob("MessagesFile[0-9]*.csv"):
            if afile.is_file() and afile.stat().st_size > 0:
                files += [afile]
        feedback.pushDebugInfo(f"{len(files)} messages files, first: {files[0]}...")
        # build digraphs
        for count, afile in enumerate(files):
            sim_id = search("\\d+", afile.stem).group(0)
            data = loadtxt(afile, delimiter=",", dtype=[("i", int32), ("j", int32), ("time", int32)], usecols=(0, 1, 2))
            feedback.pushDebugInfo(f"simulation id: {sim_id}, edges: {len(data)}")
            # build line add to sink
            for i, j, time in data:
                i_x_px, i_y_ln = id2xy(i - 1, W, H)
                i_x_geo, i_y_geo = transform_coords_to_georef(i_x_px + 0.5, i_y_ln + 0.5, GT)
                # feedback.pushDebugInfo(f"i_x_geo, i_y_geo: {i_x_geo}, {i_y_geo}, time: {time}")
                j_x_px, j_y_ln = id2xy(j - 1, W, H)
                j_x_geo, j_y_geo = transform_coords_to_georef(j_x_px + 0.5, j_y_ln + 0.5, GT)
                # feedback.pushDebugInfo(f"j_x_geo, j_y_geo: {j_x_geo}, {j_y_geo}, time: {time}")
                # TODO id = int(f"{sim_idx.zfill}_{i.zfill...}_{j}")
                feature = QgsFeature(fields)
                feature.setId(int(sim_id))
                feature.setAttributes([int(sim_id), int(time)])
                feature.setGeometry(QgsLineString([QgsPoint(i_x_geo, i_y_geo), QgsPoint(j_x_geo, j_y_geo)]))
                # feedback.pushDebugInfo(f"j_x_geo, j_y_geo: {j_x_geo}, {j_y_geo}, time: {time}, sim_idx: {sim_idx}")
                sink.addFeature(feature, QgsFeatureSink.FastInsert)
                if feedback.isCanceled():
                    break
            feedback.setProgress(int(count * len(files)))

        processing.run(
            "qgis:setstyleforvectorlayer",
            {"INPUT": dest_id, "STYLE": str(Path(assets_dir, "messages.qml"))},
            context=context,
            feedback=feedback,
            is_child_algorithm=True,
        )
        # self.dest_id = dest_id
        return {self.OUTPUT_LAYER: dest_id}

    # def postProcessAlgorithm(self, context, feedback):
    #     """Called after processAlgorithm, use it to load the layer and set the symbology"""
    #     feedback.pushDebugInfo(f"postProcessAlgorithm start {context}")
    #     # layer = QgsProcessingUtils.mapLayerFromString(self.dest_id, context)
    #     layer = context.getMapLayer(self.dest_id)
    #     layer.loadNamedStyle(str(Path(assets_dir, "messages.qml")))
    #     # layer.triggerRepaint()
    #     return {self.OUTPUT_LAYER: self.dest_id}

    def tr(self, string):
        return QCoreApplication.translate("Processing", string)

    def createInstance(self):
        return MessagesSIMPP()

    def group(self):
        return self.tr("Simulator Post Processing")

    def groupId(self):
        return "simulatorpostprocessing"

    def name(self):
        return "messages"

    def displayName(self):
        return self.tr("Messages")


class StatisticSIMPP(QgsProcessingAlgorithm):
    """Statistic Simulation Post Processing Algorithm"""

    dirs = ["FlameLength", "Intensity", "RateOfSpread", "CrownFractionBurn", "CrownFire"]
    names = ["FL", "Intensity", "ROSFile", "Cfb", "Crown"]
    # gdal_dt_str =["gdal.GDT_Float32", "gdal.GDT_Int16"],
    gdal_dt = [GDT_Float32, GDT_Int16]
    numpy_dt = [float32, int16]

    BASE_LAYER = "BaseLayer"
    ST_NAME = "StatisticName"
    ST_DIR = "StatisticDirectory"
    DATA_TYPE = "DataType"
    OUTPUT_RASTER = "OutputRaster"

    def checkParameterValues(self, parameters: dict[str, Any], context: QgsProcessingContext) -> tuple[bool, str]:
        """log file exists and is not empty"""
        st_name = self.parameterAsString(parameters, self.ST_NAME, context)
        st_dir = Path(self.parameterAsString(parameters, self.ST_DIR, context))
        if not st_dir.is_dir():
            return False, f"Provided {self.ST_DIR}: {st_dir} is not a directory"
        files = list(st_dir.glob(st_name + "[0-9]*.asc"))
        if files == []:
            return False, f"Provided {self.ST_DIR}: {st_dir} does not contain any '{st_name}[0-9]*.asc' files"
        if not any([afile for afile in files if afile.is_file() and afile.stat().st_size > 0]):
            return False, f"Provided {self.ST_DIR}: {st_dir} contains only empty '{st_name}[0-9]*.asc' files"
        return True, ""

    def initAlgorithm(self, config):
        self.addParameter(
            QgsProcessingParameterRasterDestination(
                name=self.OUTPUT_RASTER,
                description=self.tr("Output raster"),
                # defaultValue=None,
                # optional=False,
                # createByDefault=True,
            )
        )
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                name=self.BASE_LAYER,
                description=self.tr("Base raster (normally fuel or elevation) to get the geotransform"),
                defaultValue=[QgsProcessing.TypeRaster],
                optional=False,
            )
        )
        self.addParameter(
            QgsProcessingParameterFile(
                name=self.ST_DIR,
                description=(
                    f"Statistic directory (normally firesim_yymmdd_HHMMSS/results/Statistic\n any of {self.dirs}"
                ),
                behavior=QgsProcessingParameterFile.Folder,
                extension="",
                defaultValue=None,
                optional=False,
                fileFilter="",
            )
        )
        self.addParameter(
            QgsProcessingParameterString(
                name=self.ST_NAME,
                description=f"Statistic 'name[0-9]+.asc' (normally any of {self.names})",
                defaultValue=self.names[2],
                # defaultValue=None,
                optional=False,
            )
        )
        qppe = QgsProcessingParameterEnum(
            name=self.DATA_TYPE,
            description=self.tr("data type"),
            # WEIRD BUG
            # options=self.gdal_dt_str,
            options=["gdal.GDT_Float32", "gdal.GDT_Int16"],
            allowMultiple=False,
            defaultValue="gdal.GDT_Float32",
            # defaultValue=self.gdal_dt_str[0],
            optional=False,
            usesStaticStrings=True,
        )
        qppe.setFlags(qppe.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        self.addParameter(qppe)

    def processAlgorithm(self, parameters, context, feedback):
        """proc algo"""
        feedback.pushDebugInfo("processAlgorithm start")
        # get base map
        base_raster = self.parameterAsRasterLayer(parameters, self.BASE_LAYER, context)
        dataset = gdal.Open(base_raster.publicSource(), gdal.GA_ReadOnly)
        if dataset is None:
            raise FileNotFoundError(f"{base_raster} at {base_raster.publicSource()}")
        GT = dataset.GetGeoTransform()
        # "Projection": ds.GetProjection(),
        # "RasterCount": ds.RasterCount,
        W = dataset.RasterXSize
        H = dataset.RasterYSize

        # get data
        st_dir = Path(self.parameterAsString(parameters, self.ST_DIR, context))
        st_name = self.parameterAsString(parameters, self.ST_NAME, context)
        feedback.pushDebugInfo(f"st_dir: {st_dir}, st_name: {st_name}")
        files = []
        for afile in sorted(st_dir.glob(st_name + "[0-9]*.asc")):
            if afile.is_file() and afile.stat().st_size > 0:
                files += [afile]
        feedback.pushDebugInfo(f"{len(files)} {st_name} files, first: {files[0]}...")

        # raster
        output_raster_filename = self.parameterAsOutputLayer(parameters, self.OUTPUT_RASTER, context)
        raster_format = Grass7Utils.getRasterFormatFromFilename(output_raster_filename)
        feedback.pushDebugInfo(f"output_raster: {output_raster_filename}, {raster_format}")

        data_type = self.parameterAsEnum(parameters, self.DATA_TYPE, context)
        feedback.pushDebugInfo(f"data_type: {data_type}, {self.gdal_dt[data_type]}, {self.numpy_dt[data_type]}")

        dst_ds = gdal.GetDriverByName(raster_format).Create(
            output_raster_filename, W, H, len(files), self.gdal_dt[data_type]
        )
        dst_ds.SetGeoTransform(GT)  # specify coords
        dst_ds.SetProjection(base_raster.crs().authid())  # export coords to file

        # colors = get_color_table(feedback, cm = colormaps.get('magma'))
        data = []
        for count, afile in enumerate(files):
            sim_id = search("\\d+", afile.stem).group(0)
            data += [loadtxt(afile, dtype=self.numpy_dt[data_type], skiprows=6)]
            feedback.pushDebugInfo(f"simulation id: {sim_id}, data: {data[-1].shape}")
            # retval = dst_ds.GetRasterBand(count + 1)
            # feedback.pushDebugInfo(f"retval nodata: {retval}")
            # colors = get_color_table(feedback, data[-1].min(), data[-1].max(), cm=colormaps.get("magma"))
            band = dst_ds.GetRasterBand(count + 1)
            # if 0 != band.SetDescription(f"simulation id: {sim_id}"):
            #     feedback.pushWarning(f"SetDescription failed for {band}")
            # TODO
            # r"""SetUnitType(Band self, char const * val) -> CPLErr"""
            # band.SetUnitType("m/s")
            # r"""SetStatistics(Band self, double min, double max, double mean, double stddev) -> CPLErr"""
            # NOT THIS : band.SetStatistics(data[-1].min(), data[-1].max(), data[-1].mean(), data[-1].std())
            # r"""SetCategoryNames(Band self, char ** papszCategoryNames) -> CPLErr"""
            # band.SetCategoryNames(["min", "max", "mean", "stddev"])
            # ds.SetMetadata({"X_BAND": "1" }, "GEOLOCATION")
            # band.SetCategoryNames([f"simulation id: {sim_idx}"])
            # feedback.pushDebugInfo(f"colors: {colors} {colors.GetCount()}, {data[-1].min()}, {data[-1].max()}")
            # if 0 != band.SetRasterColorInterpretation(GCI_PaletteIndex):
            #     feedback.pushWarning(f"SetRasterColorInterpretation failed for {band}")
            # if 0 != band.SetRasterColorTable(colors):
            #     feedback.pushWarning(f"SetRasterColorTable failed for {band}")
            if 0 != band.SetNoDataValue(0):
                feedback.pushWarning(f"Set No Data failed for {afile}")
            if 0 != band.WriteArray(data[-1]):
                feedback.pushWarning(f"WriteArray failed for {afile}")
            if feedback.isCanceled():
                break
            # band.FlushCache()  # write to disk
            # band = None
            # colors = None
            feedback.setProgress(int(count * len(files)))
        dst_ds.FlushCache()  # write to disk
        dst_ds = None

        # attach post processor
        layer = output_raster_filename
        display_name = f"{st_name}_{self.numpy_dt[data_type].__name__}"
        context.addLayerToLoadOnCompletion(
            layer,
            context.LayerDetails(display_name, context.project(), display_name),
        )
        if True:  # context.willLoadLayerOnCompletion(layer):
            context.layerToLoadOnCompletionDetails(layer).setPostProcessor(
                # RasterPostProcessor(display_name, (0, 0, 255), (255, 0, 0))
                run_alg_styler2(display_name, (68, 1, 84), (253, 231, 37))
            )
        feedback.pushDebugInfo(f"finished")

        return {self.OUTPUT_RASTER: output_raster_filename}

    # def postProcessAlgorithm(self, context, feedback):
    #     """Called after processAlgorithm, use it to load the layer and set the symbology"""
    #     feedback.pushDebugInfo(f"postProcessAlgorithm start {context}")
    #     # layer = QgsProcessingUtils.mapLayerFromString(self.dest_id, context)
    #     layer = context.getMapLayer(self.dest_id)
    #     layer.loadNamedStyle(str(Path(assets_dir, "messages.qml")))
    #     # layer.triggerRepaint()
    #     return {self.OUTPUT_LAYER: self.dest_id}

    def tr(self, string):
        return QCoreApplication.translate("Processing", string)

    def createInstance(self):
        return StatisticSIMPP()

    def group(self):
        return self.tr("Simulator Post Processing")

    def groupId(self):
        return "zexperimental"
        # return "simulatorpostprocessing"

    def name(self):
        return "statistic"

    def displayName(self):
        return self.tr("Spatial Statistic")


class Renamer(QgsProcessingLayerPostProcessorInterface):
    def __init__(self, layer_name):
        self.name = layer_name
        super().__init__()

    def postProcessLayer(self, layer, context, feedback):
        layer.setName(self.name)


class RasterPostProcessor(QgsProcessingLayerPostProcessorInterface):
    def __init__(self, display_name, layer_color1, layer_color2):
        super().__init__()
        self.name = display_name
        self.color1 = layer_color1
        self.color2 = layer_color2

    def postProcessLayer(self, layer, context, feedback):
        feedback.pushInfo(f"Inside postProcessLayer: {self.name}")
        if layer.isValid():
            feedback.pushInfo(f"Layer valid: {self.name}")
            layer.setName(self.name)

            prov = layer.dataProvider()
            stats = prov.bandStatistics(1, QgsRasterBandStats.All, layer.extent(), 0)
            min = stats.minimumValue
            max = stats.maximumValue
            renderer = QgsSingleBandPseudoColorRenderer(layer.dataProvider(), band=1)
            color_ramp = QgsGradientColorRamp(QColor(*self.color1), QColor(*self.color2))
            renderer.setClassificationMin(min)
            renderer.setClassificationMax(max)
            renderer.createShader(color_ramp)
            layer.setRenderer(renderer)
        else:
            feedback.pushInfo(f"Layer not valid: {self.name}")


def get_color_table(feedback, amin, amax, cm=colormaps.get("magma")):
    """set colormap for a band"""
    acm = (array(to_rgba_array(cm.colors)) * 255).astype(int)
    ramp = linspace(amin, amax + 1, 255, dtype=int)
    colors = None
    colors = gdal.ColorTable()
    for i in range(254):
        ret = colors.CreateColorRamp(int(ramp[i]), tuple(acm[i]), int(ramp[i + 1]), tuple(acm[i + 1]))
        feedback.pushDebugInfo(f"i: {i}, {tuple(acm[i])}, {i+1}, {tuple(acm[i+1])}, {ret}")
    return colors


# def get_color_table(feedback, cm = colormaps.get('magma')):
#     """set colormap for a band"""
#     acm = (array(to_rgba_array(cm.colors))*255).astype(int)
#     colors = gdal.ColorTable()
#     for i in range(254):
#         ret = colors.CreateColorRamp(i, tuple(acm[i]), i+1, tuple(acm[i+1]))
#         feedback.pushDebugInfo(f"i: {i}, {tuple(acm[i])}, {i+1}, {tuple(acm[i+1])}, {ret}")
#     return colors


def run_alg_styler2(display_name, layer_color1, layer_color2):
    """Create a New Post Processor class and returns it"""

    # Just simply creating a new instance of the class was not working
    # for details see https://gis.stackexchange.com/questions/423650/qgsprocessinglayerpostprocessorinterface-only-processing-the-last-layer
    class LayerPostProcessor(QgsProcessingLayerPostProcessorInterface):
        instance = None
        name = display_name
        color1 = layer_color1
        color2 = layer_color2

        def postProcessLayer(self, layer, context, feedback):
            feedback.pushInfo(f"Inside postProcessLayer: {self.name}")
            if layer.isValid():
                prov = layer.dataProvider()
                stats = prov.bandStatistics(1, QgsRasterBandStats.All, layer.extent(), 0)
                min_value = stats.minimumValue
                max_value = stats.maximumValue
                feedback.pushInfo(f"Layer valid: {self.name}")
                layer.setName(self.name)
                fcn = QgsColorRampShader()
                fcn.setColorRampType(QgsColorRampShader.Interpolated)
                lst = [
                    QgsColorRampShader.ColorRampItem(min_value, QColor(*self.color1)),
                    QgsColorRampShader.ColorRampItem(max_value, QColor(*self.color2)),
                ]
                fcn.setColorRampItemList(lst)
                shader = QgsRasterShader()
                shader.setRasterShaderFunction(fcn)
                renderer = QgsSingleBandPseudoColorRenderer(layer.dataProvider(), 1, shader)
                layer.setRenderer(renderer)
            else:
                feedback.pushInfo(f"Layer not valid: {self.name}")

        # Hack to work around sip bug!
        @staticmethod
        def create() -> "LayerPostProcessor":
            LayerPostProcessor.instance = LayerPostProcessor()
            return LayerPostProcessor.instance

    return LayerPostProcessor.create()


def run_alg_styler(display_name, layer_color1, layer_color2):
    """Create a New Post Processor class and returns it"""

    # Just simply creating a new instance of the class was not working
    # for details see https://gis.stackexchange.com/questions/423650/qgsprocessinglayerpostprocessorinterface-only-processing-the-last-layer
    class LayerPostProcessor(QgsProcessingLayerPostProcessorInterface):
        instance = None
        name = display_name
        color1 = layer_color1
        color2 = layer_color2

        def postProcessLayer(self, layer, context, feedback):
            feedback.pushInfo(f"Inside postProcessLayer: {self.name}")
            if layer.isValid():
                feedback.pushInfo(f"Layer valid: {self.name}")
                layer.setName(self.name)

                prov = layer.dataProvider()
                stats = prov.bandStatistics(1, QgsRasterBandStats.All, layer.extent(), 0)
                min = stats.minimumValue
                max = stats.maximumValue
                renderer = QgsSingleBandPseudoColorRenderer(layer.dataProvider(), band=1)
                color_ramp = QgsGradientColorRamp(QColor(*self.color1), QColor(*self.color2))
                renderer.setClassificationMin(min)
                renderer.setClassificationMax(max)
                renderer.createShader(color_ramp)
                layer.setRenderer(renderer)
            else:
                feedback.pushInfo(f"Layer not valid: {self.name}")

        # Hack to work around sip bug!
        @staticmethod
        def create() -> "LayerPostProcessor":
            LayerPostProcessor.instance = LayerPostProcessor()
            return LayerPostProcessor.instance

    return LayerPostProcessor.create()
